from beam import *
import sympy as sp

#for decreasing gradient load
uvl = UVL(0, 6, 3, 3, inverted=True)
x = sp.Symbol('x')
print(uvl.startload, uvl.endload, uvl.gradient)
w_x = uvl.startload * sp.SingularityFunction(x, uvl.start, 0) + uvl.gradient * sp.SingularityFunction(x, uvl.start, 1)# - ( uvl.endload * sp.SingularityFunction(x, uvl.end, 0) + uvl.gradient * sp.SingularityFunction(x, uvl.end, 1))

print()
print(w_x.subs(x, 0))
print(w_x.subs(x, 1))
print(w_x.subs(x, 2))
print(w_x.subs(x, 3))
print(w_x.subs(x, 4))
print(w_x.subs(x, 5))
print(w_x.subs(x, 6))
print(w_x.subs(x, 7))
print(w_x.subs(x, 8))
print(w_x.subs(x, 12))
print()
v_x = uvl.startload * sp.SingularityFunction(x, uvl.start, 1) + uvl.gradient * sp.SingularityFunction(x, uvl.start, 2)/2# - ( uvl.endload * sp.SingularityFunction(x, uvl.end, 1) + uvl.gradient * sp.SingularityFunction(x, uvl.end, 2)/2)

print()
print(v_x.subs(x, 0))
print(v_x.subs(x, 1))
print(v_x.subs(x, 2))
print(v_x.subs(x, 3))
print(v_x.subs(x, 4))
print(v_x.subs(x, 5))
print(v_x.subs(x, 6))
print(v_x.subs(x, 7))
print(v_x.subs(x, 8))
print()

m_x = uvl.startload * sp.SingularityFunction(x, uvl.start, 2)/2 + uvl.gradient * sp.SingularityFunction(x, uvl.start, 3)/3# - ( uvl.endload * sp.SingularityFunction(x, uvl.end, 2)/2 + uvl.gradient * sp.SingularityFunction(x, uvl.end, 3)/3)
mx = ( uvl.endload * sp.SingularityFunction(x, uvl.end, 2)/2 + uvl.gradient * sp.SingularityFunction(x, uvl.end, 3)/3)
print()
print(m_x.subs(x, 0),mx.subs(x,0) )
print(m_x.subs(x, 1), mx.subs(x,1))
print(m_x.subs(x, 2), mx.subs(x,2))
print(m_x.subs(x, 3), mx.subs(x,3), m_x.subs(x, 3)- mx.subs(x,3))
print(m_x.subs(x, 4), mx.subs(x,4), m_x.subs(x, 4)- mx.subs(x,4))
print(m_x.subs(x, 5), mx.subs(x,5), m_x.subs(x, 5)- mx.subs(x,5))
print(m_x.subs(x, 6), mx.subs(x,6), m_x.subs(x, 6)- mx.subs(x,6))
print(m_x.subs(x, 7), mx.subs(x,7), m_x.subs(x, 7)- mx.subs(x,7))
print(m_x.subs(x, 8), mx.subs(x,8), m_x.subs(x, 8)- mx.subs(x,8))
print(m_x.subs(x, 9), mx.subs(x,9), m_x.subs(x, 9)- mx.subs(x,9))
print(m_x.subs(x, 12), mx.subs(x,12))
print()
quit()
uvl = UVL(0, 0, 6, 6, inverted=True)
x = sp.Symbol('x')
#for increasing gradient load
#for inverted
print(uvl.gradient)
print()
w_x = uvl.startload * sp.SingularityFunction(x, uvl.start, 0) + uvl.gradient * sp.SingularityFunction(x, uvl.start, 1) - ( uvl.endload * sp.SingularityFunction(x, uvl.end, 0) + uvl.gradient * sp.SingularityFunction(x, uvl.end, 1))
print(w_x.subs(x, 0))
print(w_x.subs(x, 2))
print(w_x.subs(x, 4))
print(w_x.subs(x, 5.99))
print(w_x.subs(x, 8))
print(w_x.subs(x, 10))
print(w_x.subs(x, 12))
print()
v_x = uvl.startload * sp.SingularityFunction(x, uvl.start, 1) + uvl.gradient * sp.SingularityFunction(x, uvl.start, 2)/2 - ( uvl.endload * sp.SingularityFunction(x, uvl.end, 1) + uvl.gradient * sp.SingularityFunction(x, uvl.end, 2)/2)
print(v_x.subs(x, 0))
print(v_x.subs(x, 2))
print(v_x.subs(x, 4))
print(v_x.subs(x, 6))
print(v_x.subs(x, 8))
print(v_x.subs(x, 10))
print(v_x.subs(x, 12))

m_x = uvl.startload * sp.SingularityFunction(x, uvl.start, 2)/2 + uvl.gradient * sp.SingularityFunction(x, uvl.start, 3)/6 - ( uvl.endload * sp.SingularityFunction(x, uvl.end, 2)/2 + uvl.gradient * sp.SingularityFunction(x, uvl.end, 3)/6)
print()
print(m_x.subs(x, 0))
print(m_x.subs(x, 1))
print(m_x.subs(x, 2))
print(m_x.subs(x, 3))
print(m_x.subs(x, 4))
print(m_x.subs(x, 5))
print(m_x.subs(x, 6))
print(m_x.subs(x, 7))
print(m_x.subs(x, 8))
print()